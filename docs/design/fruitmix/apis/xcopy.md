<!-- TOC -->

- [1. 概述](#1-概述)
- [2. 使用](#2-使用)
  - [2.1. 创建](#21-创建)
  - [2.2. 层级与执行顺序](#22-层级与执行顺序)
  - [2.3. 命名冲突](#23-命名冲突)
    - [2.3.1. 策略](#231-策略)
    - [2.3.2. Policy对象](#232-policy对象)
    - [2.3.3. 全局策略和每个子任务策略](#233-全局策略和每个子任务策略)
  - [2.4. 错误](#24-错误)
  - [2.5. 任务失败](#25-任务失败)
- [3. 实现](#3-实现)
  - [3.1. 模型](#31-模型)
  - [3.2. 依赖性](#32-依赖性)
  - [3.3. 结构](#33-结构)
    - [3.3.1. XFile](#331-xfile)
    - [3.3.2. XDir](#332-xdir)
  - [3.4. Stepper](#34-stepper)
    - [3.4.1. 调度器](#341-调度器)
    - [3.4.2. 单步](#342-单步)
    - [3.6.2. 生命周期方法](#362-生命周期方法)
- [测试](#测试)

<!-- /TOC -->

# 1. 概述

`xcopy`模块提供在服务器端批量复制和移动文件的功能。该功能不持久化任务，如果服务遭遇重启，则任务消失。

未来`xcopy`会提供服务器和云盘的上传下载功能，该功能需要持久化。


# 2. 使用

## 2.1. 创建

创建一个xcopy任务需要提供：

+ 模式，包括`copy`, `move`, `import`和`export`（未来会增加`upload`和`download`）
  + 在fruitmix文件系统内部的复制和移动使用`copy`和`move`
  + 从外部文件系统导入到fruitmix文件系统使用`import`
  + 从fruitmix文件系统导出到外部文件系统使用`export`
+ 一个源文件夹标识
+ 源文件夹下的一组文件或文件夹，以名称做标识
+ 一个目标文件夹标识

```js
{
  mode: 'copy',
  src: {
    drive: '虚拟盘uuid，或物理盘device name',
    dir: '文件夹uuid，或文件夹相对路径'
  },
  dst: {
    drive: '虚拟盘uuid，或物理盘device name',
    dir: '文件夹uuid，或文件夹相对路径'
  },
  entries: ['文件夹或文件名']，
  policies: {
    dir: [null, null],  // 用于文件夹操作遇到命名冲突时的解决策略   
    file: [null, null]  // 用于文件操作遇到命名冲突时的解决策略
  }
}
```

> 设计变更：不再需要客户端提供被文件或文件夹的UUID。


## 2.2. 层级与执行顺序

一个任务的行为具有层级结构的任务组合，每个子任务是一个文件夹任务或者一个文件任务。在任务执行顺序上采用如下设计规则：

1. 一个文件夹内既有子文件夹也有文件时，优先处理子文件夹任务；文件和文件夹均按照字母序操作；
2. 一个文件夹包含子文件夹时，采用深度优先原则；

第一条是考虑到在所有操作系统上，缺省的排列习惯都是文件夹优先于文件；

第二条是考虑如果用户浏览目标文件夹只能以top-down的方式操作，采用深度优先的原则可以明确表述任务尚未完成，而不会在上层看到建立了很多空文件夹，但并不清楚哪些件夹操作已经完成；

> 考虑到每次建立文件夹可能会带来一次readdir操作，第二条有可能变更为一次性建立完成所有文件夹。

举例如下：

```
<src>/
  hello/
    foo/
      dead/
      beef
    bar
  world
```

对于上述源文件结构，操作顺序应该是：

1. 建立hello/
2. 建立foo/
3. 建立dead
4. 复制beef
5. 复制bar
6. 复制world

## 2.3. 命名冲突

### 2.3.1. 策略

1. `undefined`或`null`, 无策略；当遇到同名对象时操作进入conflict状态，等待用户（客户端）解决；
2. `skip`, 遇到同名对象时跳过；如果源对象为文件夹，该文件夹内部的子文件夹和文件不会被继续复制或移动；
3. `merge`, 仅适用于源对下为文件夹且目标同名对象也为文件夹的情形，源文件夹内的子文件夹或文件会被继续复制或移动；
4. `replace`, 删除目标同名对象以完成复制或移动；
5. `rename`, 自动重命名；

### 2.3.2. Policy对象

1. Policy对象区分源对象和目标同名对象是相同类型还是不同类型；
2. 针对文件夹和文件使用不同的Policy；

每个policy对象用数组`[same, diff]`表示，其中`same`和`diff`分别为类型相同和类型不同时的策略；


### 2.3.3. 全局策略和每个子任务策略

全局具有`polices`属性，可以在创建任务时指定，也可以在任务运行时更新；更新全局`policies`一般在用户设置某个具体冲突时，在客户端提供“应用全部”选项，客户端可以根据该用户操作更新全局策略。

每个子任务也有自己的policy，目前的设计，每个子任务具有预设类型（根据源对象的类型）且不会变化，所以更新子任务的policy只需要提供一个policy对象。

全局策略的更新影响到所有已经冲突的任务，也影响到正在执行的任务。


## 2.4. 错误

错误不同于命名冲突；错误的任务无法重试。

对于一个文件任务而言，一个错误仅仅导致该任务进入错误状态。

对于文件夹任务，在建立目标文件夹的过程完成之后，如果遇到子任务错误，它需要考虑该子任务错误是否由当前文件夹任务的源或者目标文件夹变动所致。





可以预见到的错误包括如下类型：

1. 用户权限错误
    1. 用户不再能够访问源或目标文件夹
2. 源对象访问错误，包括：
    1. 源对象丢失
    2. 源对象类型变化
    3. 源对象为不支持的文件类型
3. 目标对象访问呢错误，包括：
    1. 目标对象为不支持的类型
4. 结构性错误
    1. 源对象的父文件夹、乃至整个任务的源文件夹，无法访问
    2. 目标对象的父文件夹、乃至整个任务的目标文件夹，无法访问



## 2.5. 任务失败

任务失败有很多种情况。

上一节的顺序要求，隐含了实现过程中需要完整读取一次目录，然后排序文件夹和文件任务的过程。

在完成读取目录之后，在子任务完成操作之前，文件系统的内容可能发生改动。这些改动可能导致：

1. 新建的文件夹或文件没有被复制或移动；
2. 文件夹和文件在对应任务执行完成之前被删除；
3. 文件夹和文件在对应任务执行完成之前被改动名称；
4. 当前（文件夹）任务对应的源文件发生变化（改名，移动到其他地方，删除）；

理论上，上述1/2/3问题可以通过把执行逻辑改为Iterator逻辑解决，即每个任务结束后都重新枚举文件夹内容，但这个做法会严重影响性能，且解决的问题是很少出现的，得不偿失。


# 3. 实现

## 3.1. 模型

`xcopy`设计为一个用户任务，它存在于vfs和nfs之外，代表用户执行操作。`xcopy`不持久化任何数据，如果遇到服务重启，则所有`xcopy`任务消失。

## 3.2. 依赖性

xcopy模块依赖vfs和nfs

## 3.3. 结构

每个task会创建一个`XCopy`对象；`XCopy`对象分为两层：context和task tree。

`XCopy`对象自身就是整个任务的context，它负责提供所有子任务所需：

1. api提供者，包括vfs和nfs；
2. 任务的全局信息，包括
    1. user
    2. src.drive和src.dir
    3. dst.drive和dst.dir
    4. entries，top level task
    5. global policies
    6. 统计和日志
    7. 全局调度器

### 3.3.1. XFile

`XFile`负责实现一个文件任务；一个文件任务包含如下状态：

1. Working，负责移动或复制文件
2. Conflict，遇到命名冲突，等待用户裁决
3. Failed，遇到错误
4. Finished，任务成功结束

`XFile`任务由全局调度器负责从文件的stat数据创建，创建的`XFile`对象成为task tree的一个节点，初始状态是`Working`；

`Working`状态需要注意的情况是在开始执行时应携带全局policy的副本，在执行结束时，如果执行结果是`Conflict`且全局`policy`发生变化，应重新执行任务；

`XFile`的父节点`XDir`对象需要侦听`XFile`的状态迁移，如果`XFile`迁移至`Failed`或者`Finished`状态，则`XFile`的生命周期结束，task tree的结构性修改是父节点的责任，触发调度器也是父节点的责任。

在职责分配上，一个状态结束时获取的数据如果影响向目标状态的迁移，则迁出的状态应该负责处理数据。

### 3.3.2. XDir

`XDir`负责一个文件夹任务；一个文件夹任务包含两个阶段：

1. 创建文件夹
2. 维护文件夹的子任务

`XDir`包含如下状态：

1. Mkdir，创建目标文件夹
2. Conflict，创建文件夹遇到命名冲突
3. Preparing，读取源文件夹内容，创建子文件夹
4. Failed，Mkdir或者Preparing遇到错误
5. Parent，等待子文件和文件任务
    + 具有子状态alarm
6. Finish，完成

`XDir`开始生命周期有两种方式：

如果目标文件夹存在，`XDir`从Preparing开始，包括根节点以这种方式开始。

在`Preparing`阶段，`XDir`执行如下步骤：

1. 读取源文件夹内容，如果遇到整体错误，迁移至Failed状态；
2. 在目标文件夹下批量建立源文件夹中的子文件夹
    + 如果遇到整体错误，迁移至Failed状态；
    + 如果遇到部分错误，计入错误统计后剔除错误的项目；
    + 如果无剩余内容，迁移至Finish状态；
    + 如果存在剩余内容，包括文件，遇到冲突的文件夹和成功建立目标文件夹的文件夹，迁移至Parent状态；

如果迁移至`Parent`状态，需要提供`fstats`和`dstats`两个数组；前者表述文件，每个元素是源文件的`stat`；后者表述文件夹，每个元素是源文件夹的`stat`，每个`stat`包含`dst`属性，其格式如下，对应`mkdir`操作的返回结果：

```js
{
  err,
  stat,
  resolved,
  policy
}
```

进入`Parent`状态时，`dstats`中的遇到冲突的项目，会立刻建立`XDir`放入children中，等待用户操作；此时`XDir`的状态是Conflict；如果用户更新了该项目的Policy，或者修改了全局的Policy，Conflict状态迁入Mkdir状态，该状态的结果是：

1. 如果失败，进入Failed状态；
2. 如果冲突，回到Conflict状态；
3. 如果成功，进入Preparing状态；

如果`Parent`状态下，`XDir`的所有children均完成，则迁入`Finish`状态。


## 3.4. Stepper

整个`xcopy`模块采用Stepper逻辑设计。

Stepper是一个灰盒逻辑，它要求状态机可以单步执行。

内部每个子任务单元并不暴露所有状态迁移给外部访问者，但是需要区分同步迁移和异步迁移，异步迁移是通过全局调度器实现的，控制该调度器可以实现单步执行。


### 3.4.1. 调度器

调度器不负责维护tree结构；tree节点自行通过Failed，Finish状态判断；

调度器负责根据Parent状态的dstats和fstats创建新的执行任务，本质上，这是一个Lazy逻辑。

调度器需要填充两种任务：文件夹任务和文件任务。

如果当前处于运行状态的文件夹不足并发限制，则创建新的文件夹任务。下述状态的文件夹是运行状态：

1. Mkdir
2. Preparing

创建新的文件夹任务指：对于Parent状态的文件夹，如果存在dstats，则根据该dstats创建任务；

如果当前处于运行状态的文件任务不足并发限制，则创建新的文件任务，下述状态的文件是运行状态：

1. Working

创建新的文件任务指：对于Parent状态的文件，如果存在fstats，则根据该fstats创建任务；

上述两个功能均由`XDir`提供方法，供调度器使用。

调度器采用深度优先的previsit方式遍历任务树，使用2-pass完成调度。

调度器采用异步方式kick；在一个同步迁移过程中可以kick多次；可以不考虑任务节点结束时层级变化的情况，包括向上和向下；最简单的办法就是任务节点进入稳态和结束态时都kick调度器，包括：

XFile

1. 进入Failed和Finish
2. 进入Conflict
    + 原则上初始化进入Conflict时不用kick，但此时XDir的Parent也会kick，所以代码中不用做特别处理；

XDir

1. 进入Failed和Finish
2. 进入Conflict
3. 进入Parent

因为调度器本质上是Lazy逻辑，即任何一个busy的任务完成后都可以去kick调度器，相当于producer-consumer模式中consumer去pull producer。

### 3.4.2. 单步

支持单步模式一方面的考虑是可以更有利于测试，另一方面它也有实现上的收益。

虽然并发组合状态机具有很好的执行效率，但是范围不清晰的并发过程让系统难以理解。解决的办法是：

1. 区分同步的状态迁移和异步的状态迁移；同步的状态迁移是在白盒角度上看的状态迁移，在黑盒角度上，它的细节不可见，只是一个step；
2. 系统调度需要提供具有确定性的算法，例如前述的调度器，采用previsit的方式调度，让调度结果具有确定性。

调度器采用异步方式调度，当系统运行在单步模式下时，测试程序或客户端可以触发一次调度，而原本系统的连续调度逻辑失效。这样：

1. 对任何一个停止状态s1，触发一次调度，根据设计，调度之后的系统状态s2是确定的；
2. 阻止连续调度，该次调度执行后到整个系统再次停止，s3的状态是确定的；

即一个单步的执行周期是：

```
s1 ---- (调度) ---> s2 ---- (执行) ---> s3
```

系统的停止状态是上述调度器的第一个pass的逻辑，在遍历整个状态数的过程中统计：

1. running file
2. conflict file
3. running dir
4. conflict dir

如果1/3均为0，则系统stopped。

单步支持首先支持在创建任务时创建为单步模式。

其次在单步时提供两种api：

1. 触发单步执行，返回调度之后系统状态，该api称为step；
2. 观察下一个停止状态，如果请求到达时任务树已经停止，则立刻返回该状态，如果请求到达是任务树尚未停止，则等待到停止时返回，该api称为watch（类似debugger的watchpoint）。

### 3.6.2. 生命周期方法

destroy操作设计为析构意义上的对象销毁，而不是对象在destroy之后需要异步迁移到成功或失败的结束状态，所以destroy可以用同步方法实现；这要求每个`Node`对象都实现destroy方法；对于执行操作的状态，应使用状态变量block操作的继续。




# 测试

四种类型组合

src 

dst

src包含dst？？？
dst包含src？？？

基础的情况是单例，有和没有冲突













