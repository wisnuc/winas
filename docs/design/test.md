说一下restful api的自动化测试的思路。

这里的测试可以是黑盒测试或者灰盒测试。

如果是黑盒测试，每个测例的setup时从系统原点开始，通过api构造测试数据和assert测试数据构造成功；被测函数执行完成后仍然是通过api实现assert。

如果是灰盒测试，每个测例可以直接从持久化数据开始，把测试数据灌入数据库或者文件系统；被测函数执行完成后，既使用api assert，也assert持久化数据。

----

测试的基本逻辑很简单，可以理解为4-tuple: [a, b, c, d]

+ a 系统预置状态
+ b 调用测试函数使用的参数
+ c api应该返回的结果
+ d 执行被测函数后系统的状态

----

结构与值

a, b, c, d四者都可以表述为结构和值。Generally speaking，系统应该存在一个函数f，在给定a,b的前提下，可以计算出c,d；当然这是以系统行为具有确定性而言的，我们仅限于讨论该情况；至少在设计上应该尽可能采用具有确定性的设计。

f(a, b) => (c, d)

----

Spec

我们在直觉上相信了f的存在，而且在确定性前提下它是一个pure function；但是我们没有回答这个f是什么。

这个f，实际上就是系统行为的spec。如果你能定出f，那么：

1. 整个系统的行为已经被确定了，
2. 这是接口意义上的（即使包含persistent data，我们可以把persistent data囊括到spec范围内），不是设计意义上的；如果是设计意义上的，d要包含系统在内存中的状态；

一个系统可以实现自动化测试的关键——这里自动化的意思不是指用脚本写了可以运行的test suite，而是指可以根据规则或者元数据，生成a,b组合，应用测试，assert c,d——就是要定出f，你能在多大程度上定出f，就能：

1. 在f覆盖的范围内，系统具有确定和完备的spec；

如果你在某个粒度上定不出f，则意味着系统缺乏严格的spec定义；给系统指定formal的spec不是一件容易的事，因为逻辑系统和符号化需要专业的数学知识，但是编程语言写出的函数，它本质上也是formal的，而且它对程序员来说更容易理解；

2. 在f可以确定的情况下，不管a,b的值空间具有多少种值，是有限的还是无限的，具有什么样的结构，理论上你都可以在代码中用预置的值列表，或者随机生成值的函数，自动产生a,b组合，根据f确定其c,d，那么自动化测试就可行了，其能做到的覆盖程度，远超过手工代码能做到的能力。

---

Tree Walking

在抽象的意义上说我们不需要区分a,b，事实上两者在Tree Walking逻辑上也经常有交叠。我们来说一下Tree Walking逻辑。


无论是a还是b，都有大量的正交组合，完全遍历所有的组合显然是没有必要的；一个api可能在权限检查这一关就返回了错误，用无法通过权限检查的参数去组合庞大的其他参数空间测试没有什么实质收益，除非程序员头脑混乱把权限检查代码埋在了奇怪的地方而不是执行逻辑的最初。


如果你对decision problem, goal tree, game theory等等概念有深入的了解，很可能你会找到更加general和更加efficient的attack spec的state space的方法。但这里我们偷个懒，用一个简单和容易理解的方式解决这个问题。

我们把需要遍历的(a,b)组合空间用tree结构组织。

假想一个Tester（agent）在行走这个tree，从root节点开始；他手上拿着很多钥匙，我们把这些钥匙分为red key和green key。red key是一组api返回错误的参数，green key是api返回成功的参数。

---

API承诺

c

green key的返回结果一般在设计上是比较完备的，大多数api文档都能达到完备的质量要求。

red key的返回结果通常在工程中比较粗糙；这里面需要注意的问题是，对非法参数组合的情况（例如x, y参数均非法），api应该给出确定的错误返回设计，而不能随机给出x错误或者y错误。

d

在绝大多数情况下，red key的api不应该改变d，按照资源模型的定义，api对系统资源的修改应该保证all-or-none原则。

green key应该对系统做出确定性的修改，也是系统的行为定义。

---

a，b 正交？

a, b 结构表述

a => setup && assert
b => tree walking, pick value
c => ?
d => ?

f(a, b) => c
f(a, b) => d

































